import 'package:drift/drift.dart';
import 'package:drift_dev/api/migrations_native.dart';
import 'package:smart_dash_analytics/smart_dash_analytics.dart';
import 'package:test/test.dart';

// The generated directory from before.
import 'schema.dart';
import 'schema_v1.dart' as v1;
import 'schema_v2.dart' as v2;

void main() {
  late SchemaVerifier verifier;

  setUpAll(() {
    // GeneratedHelper() was generated by drift, the verifier is an api
    // provided by drift_dev.
    verifier = SchemaVerifier(GeneratedHelper());
  });

  test('upgrade from v1 to v2', () async {
    // Use startAt(1) to obtain a database connection with all tables
    // from the v1 schema.
    final schema = await verifier.schemaAt(1);

    // Insert some data from the view of the old database on an independent
    // connection!
    final oldDb = v1.DatabaseAtV1(schema.newConnection());

    final offset = DateTime.now();
    await oldDb.into(oldDb.timeSeriesTable).insert(
          v1.TimeSeriesTableCompanion(
            id: const Value(1),
            name: const Value('test'),
            ts: Value(offset),
            span: Value(TimeScale.minutes.to().inMinutes),
          ),
        );
    await oldDb.into(oldDb.dataVectorTable).insert(
          v1.DataVectorTableCompanion(
            id: const Value(1),
            idx: const Value(0),
            data: const Value('[]'),
            name: const Value('test'),
            type: Value(DataVectorType.double.name),
          ),
        );
    await oldDb.into(oldDb.dataCoordsTable).insert(
          const v1.DataCoordsTableCompanion(
            rowid: Value(1),
            data: Value('[]'),
            name: Value('test'),
          ),
        );
    await oldDb.into(oldDb.dataDimsTable).insert(
          const v1.DataDimsTableCompanion(
            id: Value(1),
            data: Value('[]'),
            name: Value('test'),
          ),
        );

    await oldDb.close();

    // Run the migration on the real database class from your app
    final dbForMigration = TimeSeriesDatabase(schema.newConnection());
    await verifier.migrateAndValidate(dbForMigration, 2);
    await dbForMigration.close();

    // Make sure the user is still here with a new database at v2
    final checkDb = v2.DatabaseAtV2(schema.newConnection());

    final tsTable = await checkDb.select(checkDb.timeSeriesTable).get();
    expect(tsTable.first.name, 'test');
    expect(tsTable.first.ts, TimeSeriesDatabase.toOffset(offset));
    await checkDb.close();
  });
}
